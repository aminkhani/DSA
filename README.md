<div align="center">
  <a href="https://www.linkedin.com/in/aminkhani-ai/" targert="_blacnk">
    <img src="https://img.shields.io/badge/LinkedIn-0077B5?style=for-the-badge&logo=linkedin&logoColor=white" alt="LinkedIn Badge"/>
  <a href="mailto:aminkhani2010@gmail.com" targert="_blacnk">
    <img src="https://img.shields.io/badge/Gmail-D14836?style=for-the-badge&logo=gmail&logoColor=white" alt="Gmail Badge"/>
  </a>
  <a href="https://t.me/aminkhani_ai" targert="_blacnk">
    <img src="https://img.shields.io/badge/Telegram-2CA5E0?style=for-the-badge&logo=telegram&logoColor=white" alt="Telegram Badge"/>
  </a>  
  <a href="https://www.instagram.com/aminkhani_ai/" targert="_blacnk">
    <img src="https://img.shields.io/badge/Instagram-E4405F?style=for-the-badge&logo=instagram&logoColor=white" alt="Instagram Badge"/>
  </a>
  <a href="https://github.com/aminkhani/" targert="_blacnk">
    <img src="https://img.shields.io/badge/GitHub-100000?style=for-the-badge&logo=github&logoColor=white" alt="Github Badge" />
  </a>
</div>
<br />
<div align="center">
  <h1 align="center">Data Structure & Algorithm (DSA) Tutorial</h1>
  <p align="center"> 
    <br />
   <a href="https://github.com/aminkhani/DSA/issues/new?assignees=&labels=bug&template=bug_report.yml&title=%5BBUG%5D%3A+">üêõReport Bug</a>
   .
   <a href="https://github.com/aminkhani/DSA/issues/new?assignees=&labels=question&template=question.yml&title=%5BQUESTION%5D%3A+">‚ùìAsk Question</a>
   .
  <a href="https://github.com/aminkhani/DSA/issues/new?assignees=&labels=like&template=like.yml&title=%5BLIKE%5D%3A+">üëçLike the repo</a>
  .
  <a href="https://github.com/aminkhani/DSA/issues/new?assignees=&labels=unlike&template=unlike.yml&title=%5BUNLIKE%5D%3A+">üëéDislike the repo</a>
  </p>
  </p>
</div><br />

</div>

> **Note**
>
> üì£ You can help to improve this repo, by giving me a **‚≠êstar‚≠ê** and **‚ù§Ô∏èfollowing me‚ù§Ô∏è**

<h1 id="top">Contents</h1>
<ul>
    <li><a href="#data">Data Definition</a>
    </li>
    <li><a href="#ds_start">Data Structure Definition</a>
        <ul>
            <li><a href="#type_ds">Types of DS</a></li>
            <li><a href="#DS_operation">DS Operations</a></li>
            <li><a href="#Usage_of_DS">Usage_of_DS</a></li>
            <li><a href="#advantage_ds">Advantages of a DS</a></li>
            <li><a href="#need_ds">Need of DS</a></li>
        </ul>
    </li>
    <li><a href="#start_ds">Algorithm Definition</a>
        <ul>
            <li><a href="#char_algorithm">Characteristics of an Algorithm</a></li>
            <li><a href="#dataflow">Dataflow of an Algorithm</a></li>
            <li><a href="#need_algo">Need of Algorithms</a></li>
            <li><a href="#algo_factors">Factors of an Algorithm</a></li>
            <li><a href="#importance_algo">Importance of Algorithms</a></li>
            <li><a href="#issues_algo">Issues of Algorithms</a></li>
            <li><a href="#appro_algo">Approaches of Algorithm</a></li>
            <li><a href="#cat_algo">Categories of Algorithms</a></li>
            <li><a href="#algo_analysis">Algorithm Analysis</a></li>
            <li><a href="#algo_comlexity">Algorithm Complexity</a></li>
            <li><a href="#type_algo">Types of Algorithms</a></li>
        </ul>
    </li>
    <li><a href="#popular_ds">Popular types of Data Structures</a>
        <ul>
            <li><a href="#">Array</a></li>
            <li><a href="#">Linked List</a></li>
            <li><a href="#">Stack</a></li>
            <li><a href="#">Queue</a></li>
            <li><a href="#">Binary Tree</a></li>
            <li><a href="#">Binary Search Tree</a></li>
            <li><a href="#">Heap</a></li>
            <li><a href="#">Hashing</a></li>
            <li><a href="#">Graph</a></li>
            <li><a href="#">Matrix</a></li>
            <li><a href="#">Misc</a></li>
            <li><a href="#">Advanced Data Structure</a></li>
        </ul>
    </li>
</ul>

<h1 id="data">What is Data?</h1>

- **Data** is the **collection** of different **numbers**, **symbols**, and **alphabets** to **represent information**.

<h1 id="ds_start">What is Data Structure?</h1>

- **Data Structure** is a **storage** that is used to **store** and **organize data**. It is a way of **arranging data** on a computer so that it can be **accessed** and **updated efficiently**.
<br>

- **Data Structure** is not only used for organizing the data. It is also used for **processing**, **retrieving**, and **storing data**. There are different basic and advanced types of data structures that are used in almost every program or software system that has been developed. So we must have good knowledge about data structures
<br>

- The choice of a **good data structure** makes it possible to perform a variety of critical operations effectively. An **efficient data structure** also uses **minimum memory space and execution time** to process the structure.
<br>

- The **data structure** is **not any programming language** like **C**, **C++**, **java**, etc. It is a **set of algorithms** that we can use in any programming language to structure the data in the memory.
<br>

- **Data structure** has also defined an instance of **ADT**.**ADT** means **ABSTRACT DATA TYPE**.
  - An **ADT** tells **what** is to be done and **data structure** tells **how** it is to be done. In other words, we can say that **ADT** gives us the **blueprint** while **data structure** provides the **implementation** part.
<br>

- As the different data structures can be implemented in a particular ADT, but the different implementations are compared for time and space.
  - For example, the **Stack ADT** can be implemented by both **Arrays** and **linked list**. Suppose the **array** is **providing time efficiency** while the **linked list** is **providing space efficiency**, so the one which is the best suited for the current user's requirements will be selected.



<div align="right"><a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
<h2 id="type_ds">Types of Data Structures</h2>

- ### Primitive Data Structure
  - The **primitive data structures** are **primitive data types**. The **int**, **char**, **float**, **double**, and **pointer** are the primitive data structures that can **hold a single value**.
- ### Non-primitive Data Structure
  - Linear Data Structure
  - Non-linear Data Structure

<img src="Pic/ds.png">

## Classification of Non-Primitive Data Structure: 

- ### Linear Data Structure
  - Data structure in which data elements are **arranged sequentially** or **linearly**, where each element is attached to its previous and next adjacent elements, is called a **linear data structure**.
  <br />

  - Examples of **linear data structures** are **Array**, **Stack**, **Queue**, **Linked List**, etc.
    <br />

  - #### Static Data Structure
    - **Static data structure** has a **fixed memory size**. It is **easier to access the elements** in a **static data structure**. 
  <br>

    - An example of this **data structure** is an **Array**.
    <br>

  - #### Dynamic Data Structure
    - In **dynamic data structure**, the size is **not fixed**. It can be randomly updated during the runtime which may be considered efficient concerning the memory (space) complexity of the code. 
  <br>

    - Examples of this **data structure** are **Queue**, **Stack**, **Linked List** etc.


- ### Non-linear Data Structure
  - **Data structures** where data elements are **not placed sequentially** or **linearly** are called **non-linear data structures**. In a **non-linear data structure**, we can‚Äôt traverse all the elements in a single run only. 
  <br>

  - Examples of **non-linear data structures** are **Trees** and **Graphs**.

<div align="right"><a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

<h2 id="need_ds">Need of Data Structures</h2>

As applications are getting **complexed** and **amount of data is increasing day by day**, there may arrise the following problems:

- ### Processor Speed
  - To handle very large amout of data, high speed processing is required, but as the data is growing day by day to the billions of files per entity, processor may fail to deal with that much amount of data.

- ### Data Search 
  - Consider an inventory size of 106 items in a store, If our application needs to search for a particular item, it needs to traverse 106 items every time, results in slowing down the search process.

- ### Multiple Requests
  -  If thousands of users are searching the data simultaneously on a web server, then there are the chances that a very large server can be failed during that process

in order to **solve the above problems**, **data structures are used**. Data is organized to form a data structure in such a way that all items are not required to be searched and required data can be searched instantly.

<div align="right"><a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

<h3 id="advantage_ds">The following are the advantages of a Data Structure:</h3>

- #### Efficiency
  -  If the choice of a data structure for implementing a particular ADT is proper, it makes the program very efficient in terms of time and space.
- #### Reusability
  -  The data structure provides reusability means that multiple client programs can use the data structure.
- #### Abstraction
  -  The data structure specified by an ADT also provides the level of abstraction. The client cannot see the internal working of the data structure, so it does not have to worry about the implementation part. The client can only see the interface.

<div align="right"><a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

<h3 id ="DS_operation">Common operations that can be performed on the Data Structures are:</h3>

- #### Searching 
  - We can search for any element in a data structure.
- #### Sorting 
  - We can sort the elements of a data structure either in an ascending or descending order.
- #### Insertion
  -  We can also insert the new element in a data structure.
- #### Updation
  -  We can also update the element, i.e., we can replace the element with another element.
- #### Deletion 
  - We can also perform the delete operation to remove the element from the data structure.

<div align="right"><a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

<h3 id="Usage_of_DS">Data Structures are used in various fields such as:</h3>

- #### Operating system
- #### Graphics
- #### Computer Design
- #### Blockchain
- #### Genetics
- #### Image Processing
- #### Simulation etc.

<div align="right"><a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

<h1 id="start_ds">What is an Algorithm?</h1>

- **Algorithm** is a **process** or a **set of rules** required to perform calculations or some other problem-solving operations especially by a **computer**. 
<br>

- The **formal definition of an algorithm** is that it contains the **finite set of instructions** which are being carried in a **specific order** to perform the specific task. It is **not the complete program** or **code**; it is **just a solution (logic) of a problem**, which can be represented either as an informal description using a **Flowchart** or **Pseudocode**.

<h3 id="char_algorithm">The following are the Characteristics of an Algorithm:</h3>

- #### Input
  - An algorithm has some input values. We can pass 0 or some input value to an algorithm.
- #### Output
  - We will get 1 or more output at the end of an algorithm.
- #### Unambiguity
  - An algorithm should be unambiguous which means that the instructions in an algorithm should be **clear and simple**.
- #### Finiteness
  - An algorithm should have finiteness. Here, finiteness means that the algorithm should contain a limited number of instructions, i.e., the instructions should be **countable**.
- #### Effectiveness
  - An algorithm should be effective as each instruction in an algorithm affects the overall process.
- #### Language independent
  - An algorithm must be language-independent so that the instructions in an algorithm can be implemented in **any of the languages** with the same output.

<div align="right"><a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

<h2 id="dataflow">Dataflow of an Algorithm</h2>

- #### Problem
  - A problem can be a real-world problem or any instance from the real-world problem for which we need to create a program or the set of instructions. The set of instructions is known as an algorithm.
- #### Algorithm
  - An algorithm will be designed for a problem which is a step by step procedure.
- #### Input
  - After designing an algorithm, the required and the desired inputs are provided to the algorithm.
- #### Processing Unit
  - The input will be given to the processing unit, and the processing unit will produce the desired output.
- #### Output
  - The output is the outcome or the result of the program.

<div align="right"><a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

<h3 id="need_algo">We need Algorithms because of the following reasons:</h3>

- #### Scalability
  - It helps us to understand the scalability. When we have a big real-world problem, we need to scale it down into **small-small steps** to **easily analyze** the problem.
- #### Performance
  -  The real-world is not easily broken down into smaller steps. If the problem can be easily broken into smaller steps means that the problem is feasible.

<div align="right"><a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

<h3 id="algo_factors">The following are the factors that we need to consider for Designing an Algorithm:</h3>

- #### Modularity
  -  If any problem is given and we can break that problem into **small-small modules** or **small-small steps**, which is a basic definition of an algorithm, it means that this feature has been perfectly designed for the algorithm.
- #### Correctness 
  - The correctness of an algorithm is defined as when the **given inputs produce the desired output**, which means that the algorithm has been designed algorithm. The analysis of an algorithm has been done correctly.
- #### Maintainability
  - Here, maintainability means that the algorithm should be designed in a **very simple structured** way so that when we **redefine** the algorithm, **no major change will be done** in the algorithm.
- #### Functionality
  - It considers **various logical steps** to solve the real-world problem.
- #### Robustness
  - Robustness means that how an algorithm can **clearly define our problem**.
- #### User-friendly
  - If the algorithm is not user-friendly, then the designer will not be able to explain it to the programmer.
- #### Simplicity 
  - If the algorithm is **simple** then it is **easy to understand**.
- #### Extensibility
  - If any other algorithm designer or programmer wants to use your algorithm then it should be extensible.

<div align="right"><a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

<h2 id="importance_algo">Importance of Algorithms</h2>

- ### Theoretical Importance
  - When any real-world problem is given to us and we break the problem into small-small modules. To break down the problem, we should know all the theoretical aspects.
- ### Practical Importance
  - As we know that **theory cannot be completed without the practical implementation**. So, the importance of **algorithm** can be **considered as both theoretical and practical**.

<div align="right"><a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

<h3 id="issues_algo">The following are the issues that come while Designing an Algorithm:</h3>

- #### How to design algorithms
  -  As we know that an algorithm is a step-by-step procedure so we must follow some steps to design an algorithm.
- #### How to analyze algorithm efficiency

<div align="right"><a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

<h3 id=="appro_algo">The following are the approaches used after considering both the theoretical and practical importance of designing an algorithm:</h3>

- #### Brute force algorithm 
  - The **general logic structure** is applied to **design an algorithm**. It is also known as an **exhaustive search algorithm** that searches all the **possibilities** to provide the required solution. Such algorithms are of two types:
    - **Optimizing**
      - Finding **all the solutions of a problem** and then take out the **best solution** or if the value of the best solution is known then it will terminate if the best solution is known.
    - **Sacrificing**
      -  As soon as the best solution is found, then it will **stop**.
<br>

- #### Divide & Conquer
  -  It is a **very implementation of an algorithm**. It allows you to design an algorithm in a **step-by-step variation**. It allows you to break down the problem into **different methods**, and **valid output** is produced for the **valid input**. This valid output is passed to some other function.
<br>

- #### Greedy Algorithm
  -  It is an **algorithm paradigm** that makes an optimal choice on each iteration with the hope of getting the best solution. It is **easy to implement** and has a **faster execution time**. But, there are very rare cases in which it provides the optimal solution.
<br>

- #### Dynamic programming
  -  It makes the algorithm more **efficient** by **storing the intermediate results**. It follows **five different steps** to **find the optimal solution** for the problem:
     1. It breaks down the **problem** into a **subproblem** to find the **optimal solution**.
     2. After breaking down the problem, it finds the optimal solution out of these subproblems.
     3. **Stores the result** of the subproblems is known as **memorization**.
     4. Reuse the result so that it cannot be recomputed for the same subproblems.
     5. Finally, it computes the result of the complex program.
<br>

- #### Branch & Bound Algorithm
  - The **branch and bound algorithm** can be applied to **only integer programming problems**. This approach divides all the sets of feasible solutions into smaller subsets. These subsets are further evaluated to find the best solution.
<br>

- #### Randomized Algorithm
  - As we have seen in a **regular algorithm**, we have **predefined input and required output**. Those algorithms that have some defined set of inputs and required output, and follow some described steps are known as **deterministic algorithms**. 
<br>

  - What happens that when the **random variable** is introduced in the **randomized algorithm**?. 
    - **In a randomized algorithm**, some **random bits** are introduced by the algorithm and added in the input to produce the output, which is random in nature. Randomized algorithms are **simpler and efficient** than the **deterministic algorithm**.
<br>

- #### Backtracking
  - **Backtracking** is an **algorithmic technique** that solves the problem **recursively** and **removes the solution** if it does not satisfy the constraints of a problem.

<div align="right"><a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

<h3 id="cat_algo">The major categories of Algorithms are given below:</h3>

- #### Sort 
  - Algorithm developed for sorting the items in a certain order.
- #### Search
  - Algorithm developed for searching the items inside a data structure.
- #### Delete
  - Algorithm developed for deleting the existing element from the data structure.
- #### Insert
  - Algorithm developed for inserting an item inside a data structure.
- #### Update
  - Algorithm developed for updating the existing element inside a data structure.

<div align="right"><a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

<h2 id="algo_analysis">Algorithm Analysis</h2>

The **algorithm** can be **analyzed** in two levels, i.e., first is **before creating the algorithm**, and second is **after creating the algorithm**. The following are the two **analysis of an algorithm**:

- ### Priori Analysis 
  - Here, **priori analysis** is the **theoretical analysis** of an algorithm which is done **before implementing the algorithm**. Various factors can be considered before implementing the algorithm like **processor speed**, which has no effect on the implementation part.
<br>

- ### Posterior Analysis
  -  Here, **posterior analysis** is a **practical analysis** of an algorithm. The **practical analysis** is achieved by implementing the algorithm using any **programming language**. This analysis basically evaluate that **how much running time and space** taken by the algorithm.

<div align="right"><a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

<h2 id="algo_comlexity">Algorithm Complexity</h2>

- The **performance** of the **algorithm** can be measured in **two factors**:

### 1. Time Complexity
  - The **time complexity of an algorithm** is the ***amount of time** required to **complete the execution**. 
  <br>

  - The time **complexity of an algorithm** is denoted by the **big O notation**. 
    - Here, **big O notation** is the asymptotic notation to represent the **time complexity**.
  <br>

  - The **time complexity** is mainly calculated by **counting the number of steps** to finish the execution.
<br>

### 2. Space Complexity
  - An **algorithm's space complexity** is the **amount of space required** to solve a problem and produce an output. Similar to the **time complexity**, **space complexity** is also expressed in **big O** notation.

- ### Auxiliary Space
  - The **extra space** required by the algorithm, excluding the input size, is known as an auxiliary space. The space complexity considers both the spaces, i.e., auxiliary space, and space used by the input.
<br>

- #### Space complexity = Auxiliary space + Input size

<div align="right"><a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

<h2 id="type_algo">The following are the Types of Algorithm:</h2>

- ### Search Algorithm
  - On each day, we search for something in our day to day life. Similarly, with the case of computer, huge data is stored in a computer that whenever the user asks for any data then the computer searches for that data in the memory and provides that data to the user. There are mainly two techniques available to search the data in an array:
    1. **Linear Search**
       - Linear search is a very simple algorithm that starts searching for an element or a value from the beginning of an array until the required element is not found. It compares the element to be searched with all the elements in an array, if the match is found, then it returns the index of the element else it returns -1. This algorithm can be implemented on the unsorted list.
  <br>

    2. **Binary Search**
       - A Binary algorithm is the simplest algorithm that searches the element very quickly. It is used to search the element from the sorted list. The elements must be stored in sequential order or the sorted manner to implement the binary algorithm. Binary search cannot be implemented if the elements are stored in a random manner. It is used to find the middle element of the list.
  <br> 

- ### Sort Algorithm
  - Sorting algorithms are used to rearrange the elements in an array or a given data structure either in an ascending or descending order. The comparison operator decides the new order of the elements.
<br>

  - **Why do we need a sorting algorithm?**
    -  An efficient sorting algorithm is required for optimizing the efficiency of other algorithms like binary search algorithm as a binary search algorithm requires an array to be sorted in a particular order, mainly in ascending order.
<br>

    - It produces information in a sorted order, which is a human-readable format.
    - Searching a particular element in a sorted list is faster than the unsorted list.

<div align="right"><a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>

<h1 id="popular_ds">Popular Types of Data Structures</h1>

<div align="right"><a href="#top" targert="_blacnk"><img src="https://img.shields.io/badge/Back to up-orange?style=for-the-badge&logo=expo&logoColor=white" /></a></div>
